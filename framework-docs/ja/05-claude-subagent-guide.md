# Claude Code サブエージェント開発ガイド

Claude Codeでサブエージェントを活用した効率的な開発を行うための実践的なガイドです。

---

## 目次

1. [はじめに](#1-はじめに)
2. [Claude.mdの設定](#2-claudemdの設定)
3. [サブエージェント一覧](#3-サブエージェント一覧)
4. [開発フローの全体像](#4-開発フローの全体像)
5. [各フェーズの詳細](#5-各フェーズの詳細)
6. [サブエージェントの使い方](#6-サブエージェントの使い方)
7. [実践的なユースケース](#7-実践的なユースケース)
8. [ベストプラクティス](#8-ベストプラクティス)
9. [日本語開発でのTips](#9-日本語開発でのtips)
10. [よくある質問](#10-よくある質問)
11. [付録：クイックリファレンス](#付録クイックリファレンス)

---

## 1. はじめに

### 1.1 サブエージェントとは

サブエージェント（Subagent）は、Claude Codeが複雑なタスクを効率的に処理するために使用する専門化されたエージェントです。メインのClaudeセッションから独立したプロセスとして起動され、特定の目的に特化した処理を行います。

### 1.2 サブエージェントを使うメリット

| メリット | 説明 |
|---------|------|
| **並列処理** | 複数のタスクを同時に実行可能 |
| **コンテキスト分離** | タスクごとにコンテキストを分離し、効率的に処理 |
| **専門化** | 各エージェントが特定のタスクに最適化 |
| **自律性** | 複雑なマルチステップタスクを自律的に完了 |

### 1.3 基本原則

- **役割分担の厳守**: 各エージェントは自分の役割範囲内でのみ作業を行う
- **不明点の確認**: 曖昧な点は勝手に仮定せず、必ず確認する
- **参照範囲の遵守**: 機密情報へのアクセスを禁止し、必要なファイルのみを参照する

---

## 2. Claude.mdの設定

### 2.1 Claude.mdとは

`CLAUDE.md`はプロジェクトのルートに配置する設定ファイルで、Claudeにプロジェクト固有のコンテキストや指示を提供します。

### 2.2 日本語プロジェクト向けCLAUDE.mdの例

```markdown
# プロジェクト概要

このプロジェクトは[プロジェクト名]です。

## 言語設定

- **開発言語**: 日本語
- **コメント**: 日本語で記述
- **コミットメッセージ**: 日本語で記述
- **ドキュメント**: 日本語で作成

## 技術スタック

- フロントエンド: [フレームワーク / 言語]
- バックエンド: [フレームワーク / 言語]
- データベース: [データベース]
- テスト: [テストフレームワーク]

## プロジェクト構造

```
src/
├── [モジュール1]/  # プロジェクトに応じた構成
├── [モジュール2]/  # プロジェクトに応じた構成
├── services/      # ビジネスロジック
└── utils/         # ユーティリティ関数
```

> **注**: ディレクトリ構造はプロジェクトの技術スタックに合わせて調整してください。

## 開発規約

### コーディングスタイル

命名規則はプロジェクトの言語・フレームワークの慣習に従ってください。

- 関数名・変数名: [camelCase/snake_case]
- クラス/型名: PascalCase
- 定数: UPPER_SNAKE_CASE
- ファイル名: [kebab-case/snake_case]

### コメント規約

- 関数の説明は日本語でドキュメントコメント形式（JSDoc, docstring等）で記述
- 複雑なロジックには日本語でインラインコメントを追加

### Git規約

- コミットメッセージは日本語で記述
- プレフィックス: feat:, fix:, docs:, refactor:, test:, chore:

例：
- `feat: ユーザー認証機能を追加`
- `fix: ログインエラーを修正`

## よく使うコマンド

プロジェクトで使用するビルドツール・パッケージマネージャに合わせて記載してください。

```bash
# 開発サーバー起動
[コマンド]

# テスト実行
[コマンド]

# ビルド
[コマンド]
```

## 注意事項

- 環境変数は`.env.local`で管理（コミット禁止）
- APIキーなどの機密情報をコードに含めない
- 新しい依存関係の追加時は事前に相談
```

### 2.3 CLAUDE.mdのベストプラクティス

1. **簡潔に保つ**: 必要な情報のみを記載
2. **構造化する**: セクションを明確に分ける
3. **更新を忘れない**: プロジェクトの変更に合わせて更新
4. **チーム共有**: バージョン管理に含める

---

## 3. サブエージェント一覧

### 3.1 役割グループ別一覧

| 役割グループ | エージェント | 説明 |
|-------------|-------------|------|
| **Planner** | req-analyzer | 要求分析、要件定義 |
| **Planner** | spec-planner | 仕様策定、技術仕様書作成 |
| **Designer** | tech-leader | 技術選定、アーキテクチャ方針決定 |
| **Designer** | frontend-designer | UI/UX設計、コンポーネント設計 |
| **Designer** | backend-designer | API設計、データベース設計 |
| **Builder** | code-builder | コード実装、テスト作成 |
| **Reviewer** | code-reviewer | コードレビュー、品質保証 |
| **Reviewer** | code-debugger | バグ調査、修正 |
| **Guide** | code-guide | コードベースの案内、説明 |
| **Guide** | general-purpose | 汎用タスク対応 |

### 3.2 各エージェント詳細

#### req-analyzer（要求分析者）

| 項目 | 内容 |
|------|------|
| **役割** | 曖昧な要求を具体的な要件に変換する分析者 |
| **用途** | 要求の明確化、要件定義、ステークホルダーニーズの特定 |
| **特徴** | 質問力、要件の構造化、曖昧さの排除 |
| **出力** | 要件一覧、ユースケース、受け入れ基準 |

#### spec-planner（仕様策定者）

| 項目 | 内容 |
|------|------|
| **役割** | 要件を実装可能な技術仕様に変換するプランナー |
| **用途** | 技術仕様書の作成、API設計、データモデル設計 |
| **特徴** | 詳細志向、一貫性の確保、実装可能性の検証 |
| **出力** | 技術仕様書、API仕様、データスキーマ |

#### tech-leader（テックリード）

| 項目 | 内容 |
|------|------|
| **役割** | 技術選定、アーキテクチャ設計、チーム技術指針の策定 |
| **用途** | 技術スタック選定、設計パターン決定、技術的課題の解決 |
| **特徴** | 俯瞰的視点、トレードオフ分析、ベストプラクティスの適用 |
| **出力** | 技術選定理由、アーキテクチャ図、設計ガイドライン |

#### frontend-designer（フロントエンド設計者）

| 項目 | 内容 |
|------|------|
| **役割** | UI/UX設計、コンポーネント設計、フロントエンドアーキテクチャ |
| **用途** | コンポーネント構造設計、状態管理設計、スタイリング方針策定 |
| **特徴** | ユーザー体験重視、再利用性の考慮、パフォーマンス最適化 |
| **出力** | コンポーネント設計、画面遷移図、状態管理設計 |

#### backend-designer（バックエンド設計者）

| 項目 | 内容 |
|------|------|
| **役割** | API設計、データベース設計、バックエンドアーキテクチャ |
| **用途** | RESTful API設計、データモデリング、認証・認可設計 |
| **特徴** | スケーラビリティ重視、セキュリティ考慮、効率的なデータアクセス |
| **出力** | API設計書、ER図、シーケンス図 |

#### code-builder（コードビルダー）

| 項目 | 内容 |
|------|------|
| **役割** | 設計仕様に基づいたコードの実装 |
| **用途** | 機能実装、テストコード作成、リファクタリング |
| **特徴** | 高品質なコード生成、コーディング規約遵守、効率的な実装 |
| **出力** | 実装コード、テストコード、ドキュメントコメント |

#### code-reviewer（コードレビューワー）

| 項目 | 内容 |
|------|------|
| **役割** | コードの品質、セキュリティ、パフォーマンスをレビュー |
| **用途** | コード品質チェック、バグ検出、セキュリティ問題の発見 |
| **観点** | 品質、バグ、セキュリティ、プロジェクト標準への準拠 |
| **出力** | レビューコメント、改善提案、修正箇所の指摘 |

#### code-debugger（コードデバッガー）

| 項目 | 内容 |
|------|------|
| **役割** | バグの原因特定、根本原因分析、修正案の提示 |
| **用途** | エラー調査、デバッグ、パフォーマンス問題の診断 |
| **特徴** | 論理的な原因追跡、再現手順の特定、効果的な修正提案 |
| **出力** | 原因分析レポート、修正コード、再発防止策 |

#### code-guide（コードガイド）

| 項目 | 内容 |
|------|------|
| **役割** | コードベースの案内、実装箇所の特定、コード理解の支援 |
| **用途** | ファイル検索、コード検索、アーキテクチャの説明 |
| **特徴** | 高速な検索、わかりやすい説明、コンテキストの提供 |
| **出力** | ファイル一覧、コード説明、構造図 |

#### general-purpose（汎用エージェント）

| 項目 | 内容 |
|------|------|
| **役割** | あらゆるタスクに対応できる万能エージェント |
| **用途** | 複雑な調査、コード検索、マルチステップタスク、その他分類困難なタスク |
| **特徴** | 高い自律性、広範なツールアクセス、柔軟な問題解決能力 |
| **使用ツール** | すべてのツール |

---

## 4. 開発フローの全体像

### 4.1 フロー図

```
┌─────────────────────────────────────────────────────────────────────┐
│                        開発フロー全体図                              │
└─────────────────────────────────────────────────────────────────────┘

  [ユーザー要求]
       │
       ▼
  ┌─────────────┐
  │req-analyzer │ ─────────► 要件定義書、ユースケース
  │ (要求分析)   │
  └──────┬──────┘
         │
         ▼
  ┌─────────────┐
  │spec-planner │ ─────────► 技術仕様書、データモデル
  │ (仕様策定)   │
  └──────┬──────┘
         │
         ▼
  ┌─────────────┐
  │tech-leader  │ ─────────► 技術選定ドキュメント、アーキテクチャ方針
  │ (技術選定)   │
  └──────┬──────┘
         │
    ┌────┴────┐
    ▼         ▼
┌────────┐ ┌────────┐
│frontend│ │backend │ ────► コンポーネント設計書、API設計書、DB設計書
│designer│ │designer│
└───┬────┘ └───┬────┘
    │          │
    └────┬─────┘
         │
         ▼
  ┌─────────────┐
  │code-builder │ ─────────► 実装コード、テストコード
  │ (実装)       │
  └──────┬──────┘
         │
         ▼
  ┌─────────────┐
  │code-reviewer│ ─────────► レビュー結果、改善提案
  │ (レビュー)   │
  └──────┬──────┘
         │
         ▼ （問題発見時）
  ┌─────────────┐
  │code-debugger│ ─────────► バグ分析レポート、修正案
  │ (デバッグ)   │
  └─────────────┘
```

### 4.2 開発フェーズとエージェントの対応

```
要求 → 分析 → 仕様 → 設計 → 実装 → レビュー → 保守
  │      │      │      │      │       │       │
  │      │      │      │      │       │       └─ code-debugger
  │      │      │      │      │       └─ code-reviewer
  │      │      │      │      └─ code-builder
  │      │      │      └─ tech-leader / frontend-designer / backend-designer
  │      │      └─ spec-planner
  │      └─ req-analyzer
  └─ general-purpose（全フェーズ対応）/ code-guide（全フェーズ対応）
```

### 4.3 成果物の引き継ぎフロー

```
┌──────────────┐
│ req-analyzer │
│  要件定義書   │
│ ユースケース  │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ spec-planner │
│  技術仕様書   │
│データモデル   │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ tech-leader  │
│ 技術選定書   │
│ ARC方針      │
└──────┬───────┘
       │
   ┌───┴───┐
   ▼       ▼
┌──────┐ ┌──────┐
│front │ │back  │
│設計書 │ │設計書 │
└──┬───┘ └──┬───┘
   │        │
   └───┬────┘
       ▼
┌──────────────┐
│ code-builder │
│  実装コード   │
│テストコード   │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│code-reviewer │
│ レビュー結果  │
└──────────────┘
```

---

## 5. 各フェーズの詳細

### 5.1 Phase 1: 要求分析（req-analyzer）

ユーザーの曖昧な要求を具体的な要件に変換します。

#### 呼び出し方

```
req-analyzer として、以下の要求を分析してください：
「ユーザーがタスクを管理できる機能が欲しい」
```

#### 主な作業内容

- ユーザー要求の分析と明確化
- 機能要件・非機能要件の整理
- ユースケースの作成
- 受け入れ基準の策定

#### 出力成果物

| 成果物 | 説明 | 引き継ぎ先 |
|--------|------|-----------|
| 要件定義書 | 機能要件、非機能要件、受け入れ基準 | spec-planner |
| ユースケース | 利用シナリオ | spec-planner, frontend-designer |
| 未解決事項リスト | 確認が必要な事項 | ユーザー |

#### 質問の観点（5W1H）

- **Who**: 誰がこの機能を使うのか
- **What**: 具体的に何ができるべきか
- **When**: いつ・どのような条件で使うのか
- **Where**: どの画面・エンドポイントで提供するのか
- **Why**: なぜこの機能が必要なのか
- **How**: どのように動作すべきか

---

### 5.2 Phase 2: 仕様策定（spec-planner）

要件を実装可能な技術仕様に変換します。

#### 呼び出し方

```
spec-planner として、以下の要件から技術仕様を策定してください：
[req-analyzerの出力した要件定義書]
```

#### 主な作業内容

- 機能仕様書の作成
- 概念データモデルの設計
- インターフェース契約の定義
- 制約・ルールの定義

#### 出力成果物

| 成果物 | 説明 | 引き継ぎ先 |
|--------|------|-----------|
| 技術仕様書 | 機能仕様、データモデル、制約 | backend-designer, frontend-designer |

#### 注意事項

- 「何を作るか」を定義（「どう作るか」はdesignerの役割）
- 実装詳細には踏み込まない

---

### 5.3 Phase 3: 技術選定（tech-leader）

プロジェクトに最適な技術スタックとアーキテクチャを決定します。

#### 呼び出し方

```
tech-leader として、以下の仕様に基づいて技術選定を行ってください：
[spec-plannerの出力した技術仕様書]
```

#### 主な作業内容

- 技術スタックの選定（言語、フレームワーク、DB等）
- アーキテクチャ方針の決定
- 設計原則の策定
- トレードオフ分析

#### 出力成果物

| 成果物 | 説明 | 引き継ぎ先 |
|--------|------|-----------|
| 技術選定ドキュメント | 採用技術とその理由 | 全設計者、code-builder |
| アーキテクチャ方針 | 構成パターン、設計原則 | backend-designer, frontend-designer |

#### 意思決定の観点

1. ビジネス要件との整合性
2. チームの習熟度
3. エコシステムの充実度
4. 将来性
5. コスト

---

### 5.4 Phase 4: 設計（frontend-designer / backend-designer）

具体的な実装設計を行います。

#### frontend-designer

```
frontend-designer として、以下の仕様に基づいてUI設計を行ってください：
[技術仕様書 + tech-leaderの方針]
```

**主な作業内容**:
- コンポーネント設計
- 状態管理設計
- 画面設計
- スタイリング方針

**出力成果物**:
- コンポーネント設計書
- 画面設計書
- 状態管理設計書

#### backend-designer

```
backend-designer として、以下の仕様に基づいてAPI・DB設計を行ってください：
[技術仕様書 + tech-leaderの方針]
```

**主な作業内容**:
- APIエンドポイントの詳細設計
- データベースの物理設計
- 認証・認可フローの設計
- インテグレーション設計

**出力成果物**:
- API設計書
- DB設計書
- シーケンス図

---

### 5.5 Phase 5: 実装（code-builder）

設計仕様に基づいてコードを実装します。

#### 呼び出し方

```
code-builder として、以下の設計に基づいて実装してください：
[frontend-designer / backend-designerの設計書]
```

#### 実装の流れ

1. **仕様確認**: 実装すべき内容を明確化
2. **既存コード確認**: 関連する既存実装を把握
3. **実装**: 仕様に従ってコードを記述
4. **テスト作成**: ユニットテストを作成
5. **動作確認**: 正しく動作することを確認

#### 出力成果物

| 成果物 | 説明 | 引き継ぎ先 |
|--------|------|-----------|
| 実装コード | 機能実装 | code-reviewer |
| テストコード | ユニットテスト、インテグレーションテスト | code-reviewer |
| 実装報告 | 変更ファイル、注意事項 | ユーザー |

---

### 5.6 Phase 6: レビュー（code-reviewer）

コードの品質、セキュリティ、パフォーマンスを評価します。

#### 呼び出し方

```
code-reviewer として、以下の実装をレビューしてください：
[code-builderの実装コード]
```

#### レビュー観点

| 観点 | チェック項目 |
|------|-------------|
| コード品質 | 命名、責務、重複、エラーハンドリング |
| セキュリティ | SQLインジェクション、XSS、認証・認可 |
| パフォーマンス | N+1問題、不要ループ、メモリリーク |
| テスト | カバレッジ、エッジケース |
| 設計 | SOLID原則、抽象化、依存関係 |

#### 重要度の定義

| レベル | 意味 | 対応 |
|--------|------|------|
| Critical | セキュリティ問題、データ損失の可能性 | 即座に修正必須 |
| Major | バグ、パフォーマンス問題 | マージ前に修正 |
| Minor | コード品質、スタイルの問題 | 修正推奨 |
| Suggestion | 改善提案 | 検討事項 |

---

### 5.7 Phase 7: デバッグ（code-debugger）

バグの特定と修正を行います。

#### 呼び出し方

```
code-debugger として、以下のバグを調査してください：
[エラー内容、再現手順]
```

#### デバッグの流れ

1. **問題の理解**: エラーメッセージ、期待動作との差異
2. **情報収集**: エラーログ、スタックトレース分析
3. **仮説立案**: 考えられる原因の列挙
4. **検証**: ログ追加、最小再現ケース作成
5. **修正と確認**: 根本原因への対処、副作用確認

#### 出力成果物

| 成果物 | 説明 | 引き継ぎ先 |
|--------|------|-----------|
| バグ分析レポート | 根本原因、修正案 | code-builder |
| 修正コード | 修正実装 | code-reviewer |
| 再発防止策 | 横展開すべき対策 | tech-leader |

---

## 6. サブエージェントの使い方

### 6.1 基本的な呼び出し方

サブエージェントはユーザーのリクエストに応じて自動的に選択されますが、明示的に指定することもできます。

**暗黙的な呼び出し（推奨）：**
```
「このプロジェクトの構造を教えて」
→ code-guideエージェントが自動選択される

「新機能の実装計画を立てて」
→ spec-plannerエージェントが自動選択される

「この要求を分析して」
→ req-analyzerエージェントが自動選択される
```

**明示的な呼び出し：**
```
「code-guideエージェントを使って認証関連のコードを探して」
「spec-plannerエージェントで実装手順を設計して」
「tech-leaderエージェントでアーキテクチャを検討して」
```

### 6.2 並列実行

複数の独立したタスクを同時に実行できます。

**例：複数の調査を並列実行**
```
「以下を並列で調査して：
1. 認証機能の実装箇所
2. データベース接続の設定
3. APIエンドポイントの一覧」
```

### 6.3 バックグラウンド実行

長時間かかるタスクをバックグラウンドで実行できます。

**例：**
```
「テストをバックグラウンドで実行しながら、コードレビューを進めて」
```

### 6.4 エージェントの再開

以前のエージェントセッションを再開して、コンテキストを維持したまま作業を続けられます。

**例：**
```
「さっきの調査の続きをして」
「先ほどのPlanエージェントの結果を踏まえて実装を始めて」
```

---

## 7. 実践的なユースケース

### 7.1 新機能の実装

**ユーザー要求**: 「ユーザーがタスクを作成・編集・削除できる機能を追加したい」

#### Step 1: 要求分析

```
req-analyzer として、以下の要求を分析してください：
「ユーザーがタスクを作成・編集・削除できる機能を追加したい」
```

**出力例**:
- 機能要件: タスクのCRUD操作
- 非機能要件: レスポンス1秒以内
- ユースケース: UC-1 タスク作成、UC-2 タスク編集...

#### Step 2: 仕様策定

```
spec-planner として、以下の要件から技術仕様を策定してください：
[req-analyzerの出力]
```

**出力例**:
- データモデル: Task { id, title, description, status, ... }
- API仕様概要: POST /tasks, GET /tasks/:id, ...

#### Step 3: 技術選定

```
tech-leader として、技術選定を行ってください
```

#### Step 4: 設計

```
backend-designer として、API・DB設計を行ってください
frontend-designer として、UI設計を行ってください
```

#### Step 5: 実装

```
code-builder として、設計に基づいて実装してください
```

#### Step 6: レビュー

```
code-reviewer として、実装をレビューしてください
```

---

### 7.2 バグ修正

**報告**: 「タスク編集時にデータが保存されない」

#### Step 1: デバッグ

```
code-debugger として、以下のバグを調査してください：
「タスク編集時にデータが保存されない」
再現手順: 1. タスクを開く 2. 内容を編集 3. 保存ボタンを押す
```

**出力例**:
- 根本原因: APIリクエストのペイロードにIDが含まれていない
- 修正案: editTask関数でIDをリクエストに含める

#### Step 2: 修正実装

```
code-builder として、以下の修正を実装してください：
[code-debuggerの修正案]
```

#### Step 3: レビュー

```
code-reviewer として、修正をレビューしてください
```

---

### 7.3 リファクタリング

```
ステップ1: 現状分析
「usersモジュールの構造を分析して改善点を洗い出して」
→ code-guideエージェントが分析

ステップ2: 設計
「リファクタリング計画を立てて」
→ tech-leaderエージェントが設計方針を作成

ステップ3: 実行
「計画に沿ってリファクタリングを実行して」
→ code-builderエージェントが実行

ステップ4: レビュー
「リファクタリング結果をレビューして」
→ code-reviewerエージェントがレビュー
```

---

### 7.4 コードベースの理解

```
code-guide として、認証機能の実装箇所と仕組みを説明してください
```

**出力例**:
- 認証は `src/services/auth-service.ts` で実装
- JWTトークンを使用、有効期限は1時間
- ミドルウェアは `src/middleware/auth.ts`

---

## 8. ベストプラクティス

### 8.1 効果的なプロンプトの書き方

**良い例：**
```
✅ 「src/services配下のAPI呼び出しパターンを調査し、
    共通化できる箇所を特定して」

✅ 「認証機能を実装したい。
    - JWTトークンを使用
    - リフレッシュトークン対応
    - セッション管理はRedisで」
```

**悪い例：**
```
❌ 「コードを見て」（目的が不明確）

❌ 「いい感じにして」（曖昧すぎる）
```

### 8.2 エージェント選択のガイドライン

| シチュエーション | 推奨エージェント |
|----------------|-----------------|
| 要求を明確にしたい | req-analyzer |
| 技術仕様を策定したい | spec-planner |
| アーキテクチャを決めたい | tech-leader |
| UIコンポーネント設計 | frontend-designer |
| API/DB設計 | backend-designer |
| コードを実装したい | code-builder |
| コードをレビューしたい | code-reviewer |
| バグを調査・修正したい | code-debugger |
| コードの場所を知りたい | code-guide |
| 複雑な調査が必要 | general-purpose |

### 8.3 パフォーマンス最適化

1. **適切な徹底度を選ぶ**
   - 簡単な検索: quick
   - 通常の調査: medium
   - 包括的な分析: very thorough

2. **並列実行を活用**
   - 独立したタスクは並列で実行
   - 依存関係があるタスクは順次実行

3. **コンテキストを明確に**
   - 必要な情報を最初に提供
   - 曖昧さを減らす

### 8.4 よくある問題と解決策

| 問題 | 解決策 |
|------|--------|
| エージェントが期待と異なる動作 | プロンプトをより具体的に |
| 処理が遅い | 徹底度を下げる / スコープを絞る |
| 結果が不十分 | 追加の調査を依頼 / 徹底度を上げる |

---

## 9. 日本語開発でのTips

### 9.1 日本語でのコミュニケーション

Claude Codeは日本語での指示を完全に理解できます。自然な日本語で指示してください。

```
✅ 「ユーザー登録機能を実装して」
✅ 「このエラーの原因を調べて」
✅ 「テストを書いて」
```

### 9.2 日本語コメントの扱い

コード内の日本語コメントも正しく理解・生成されます。

**例（TypeScript）:**
```typescript
// ✅ 日本語コメントOK
/**
 * ユーザーを作成する
 * @param name - ユーザー名
 * @returns 作成されたユーザー
 */
function createUser(name: string): User {
  // バリデーションを実行
  validateName(name);

  // ユーザーを保存
  return saveUser({ name });
}
```

他の言語でも同様に日本語コメントが使用可能です。

### 9.3 日本語ファイル名の注意点

ファイル名は英語を推奨しますが、日本語も使用可能です。

```
✅ 推奨: user-service.ts
⚠️ 可能だが非推奨: ユーザーサービス.ts
```

### 9.4 日本語でのGit操作

```bash
# 日本語コミットメッセージ
git commit -m "feat: ログイン機能を追加"

# 日本語ブランチ名（非推奨だが可能）
git checkout -b feature/ログイン  # 非推奨
git checkout -b feature/login     # 推奨
```

### 9.5 エラーメッセージの日本語化

ユーザー向けエラーメッセージは日本語で実装できます。

**例（TypeScript/JavaScript）:**
```typescript
const errorMessages = {
  required: '入力必須です',
  invalidEmail: 'メールアドレスの形式が正しくありません',
  tooShort: '{min}文字以上で入力してください',
};
```

他の言語でも同様の方法でエラーメッセージを日本語化できます。

---

## 10. よくある質問

### Q1: どのエージェントを使えばいいかわからない

**A**: 以下の判断基準を参考にしてください：

| やりたいこと | 使用エージェント |
|-------------|-----------------|
| 要求を整理したい | req-analyzer |
| 仕様を作りたい | spec-planner |
| 技術を選定したい | tech-leader |
| UI/コンポーネントを設計したい | frontend-designer |
| API/DBを設計したい | backend-designer |
| コードを書きたい | code-builder |
| コードをレビューしたい | code-reviewer |
| バグを直したい | code-debugger |
| コードの場所を知りたい | code-guide |
| 上記に当てはまらない | general-purpose |

### Q2: エージェントを省略できる？

**A**: 小規模な変更の場合は一部のフェーズを省略できます。ただし、以下は省略しないことを推奨します：
- **新機能開発**: req-analyzer → spec-planner → 設計 → 実装
- **バグ修正**: code-debugger → code-builder → code-reviewer

### Q3: 複数のエージェントを同時に使える？

**A**: 独立したタスクであれば並列実行可能です。例えば、frontend-designerとbackend-designerは同時に作業できます。ただし、依存関係がある場合は順番に実行してください。

---

## 付録：クイックリファレンス

### サブエージェント早見表

| やりたいこと | 使うエージェント | 例 |
|-------------|-----------------|-----|
| 要求を分析する | req-analyzer | 「この機能要求を分析して」 |
| 仕様を策定する | spec-planner | 「API仕様を策定して」 |
| 技術選定する | tech-leader | 「最適なアーキテクチャを提案して」 |
| UI設計する | frontend-designer | 「コンポーネント構造を設計して」 |
| API設計する | backend-designer | 「APIエンドポイントを設計して」 |
| コードを実装する | code-builder | 「この機能を実装して」 |
| コードをレビューする | code-reviewer | 「この変更をレビューして」 |
| バグを修正する | code-debugger | 「このエラーの原因を特定して」 |
| コードを探す・理解する | code-guide | 「認証関連のファイルを探して」 |
| 複雑な調査 | general-purpose | 「依存関係の影響を調査して」 |

### よく使うプロンプトテンプレート

```
# 調査系
「{対象}について調査して、{観点}を教えて」

# 実装系
「{機能}を実装して。要件は{要件}」

# レビュー系
「{対象}をレビューして、{観点}をチェックして」

# 計画系
「{目標}を達成するための実装計画を立てて」
```

---

## 参考資料

- 各エージェントの詳細定義: `.claude/agents/*.md`
- [Serena MCP 統合ガイド](./08-serena-integration-guide.md) - LSPを活用したセマンティックコード操作
- [Command・Skill・Agent 使い分けガイド](./07-command-skill-agent-guide.md)

---

*このガイドは随時更新されます。最新情報はClaude Codeの公式ドキュメントを参照してください。*
