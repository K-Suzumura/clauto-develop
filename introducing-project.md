# **Claude CodeでClauto Develop**

## *～Claude Code × スペック駆動開発の実践フレームワーク～*

## **0. はじめに**

Claude Code は強力なCLIツールですが、実務で使いこなすには「とりあえず使ってみよう」というレベルではなく、より体系的で実践的なアプローチが求められるようになってきています。

私自身のClaude Codeを使った開発経験を基に、Claude Code × スペック駆動開発の実践フレームワークを「Clauto Develop」という形でまとめ、GitHub（[**clauto-develop**](https://github.com/K-Suzumura/clauto-develop)）に公開しました。

「Clauto」というのは、「Claude」と「玄人」（エキスパート、プロフェッショナルという意味で）を掛け合わせた言葉遊び（play on words）の造語です。

このフレームワークは、Claude Code の開発者 Boris Cherny 氏が提唱する「7つのベストプラクティス」を、**スペック駆動開発（SpecDD）** の思想で体系的にまとめたものです。

このフレームワークを使えば、Claude Codeを使ったAI駆動開発を「PoC」から「実務」へとレベルアップさせることができます。

ここでは、GitHubプロジェクト [**clauto-develop**](https://github.com/K-Suzumura/clauto-develop) の詳細を説明する前に、AIと人間が高度に連携するための実践的フレームワークを解説します。

## **1. なぜ今、フレームワークが必要なのか？**

Claude Code は「Agentic Coding（自律的コーディング）」を可能にしますが、そのまま使うと以下のような問題に直面します。

* **コンテキストの爆発:** 長時間のセッションでAIが指示を忘れ、品質が劣化する
* **Vibe Coding（雰囲気コーディング）:** 明確な設計なしにコードを生成し、バグの温床になる
* **一貫性の欠如:** プロンプトの書き方によって成果物の品質がバラつく

これらを解決するのが、**スペック駆動開発（SpecDD）** の導入です。「仕様（Spec）を定義し、計画（Plan）を立て、実装（Impl）する」というプロセスを強制することで、AIの自律性を制御可能なものにします。

## **2. Boris Cherny の「7つのベストプラクティス」**

Claude Code の生みの親である Boris Cherny 氏は、AI開発における重要な指針を示しています。clauto-develop はこれらを具現化するために設計されています。

1. **Project Memory（CLAUDE.md）の徹底管理:**
   プロジェクトのルール、慣習、過去の失敗を CLAUDE.md に集約し、AIの「長期記憶」とする
2. **Plan Mode の常時利用:**
   いきなりコードを書かせず、必ず「計画」を立てさせ、人間が承認してから実装に移る
3. **Verification Loops（検証ループ）:**
   コードを書くたびにテストやLintを実行し、AI自身に品質を担保させる
4. **Slash Commands による定型化:**
   頻出するワークフロー（コミット、テスト、仕様作成）をコマンド化し、再現性を高める
5. **Sub-agents（サブエージェント）の活用:**
   「レビュアー」「テスター」など、特定の役割を持つエージェントにタスクを委譲する
6. **Parallel Execution（並列実行）:**
   複数のClaudeインスタンスを立ち上げ、異なるタスクを同時進行させる（人間の待ち時間を減らす）
7. **High-Quality Models:**
   速度よりも質を重視し、推論能力の高いモデル（Opus 4.5など）をデフォルトで採用する

## **3.「Clauto-Develop」フレームワークの機能**

このプロジェクトでは、スペック駆動開発（SpecDD）の流れに沿って、上記のベストプラクティスを踏まえたAI駆動開発が行えるように、Claude Code の使い方を提示します。

Claude Code には、**スラッシュコマンド（Slash Commands）**、**スキル（Skills）**、**サブエージェント（Sub-agents）** という3つの拡張機能があります。clauto-develop では、これらの機能を活用したカスタム設定をパッケージ化して提供しています。

### **3-1. スラッシュコマンド（Slash Commands）**

スラッシュコマンドは、対話の中で呼び出せるショートカットです。

#### **Claude Code 公式コマンド**

Claude Code には、以下のような組み込みコマンドが用意されています。

| コマンド | 機能 |
| :---- | :---- |
| `/help` | ヘルプを表示 |
| `/clear` | 会話をリセット |
| `/compact` | 会話を要約してコンテキストを圧縮 |
| `/cost` | 現在のセッションのコストを表示 |
| `/config` | 設定パネルを開く |
| `/mcp` | MCP（Model Context Protocol）機能にアクセス |

#### **カスタムコマンド（clauto-develop 提供）**

clauto-develop では、スペック駆動開発のプロセスを標準化するための13種類のカスタムコマンドを提供しています。

| コマンド | 機能 | SpecDD上の役割 |
| :---- | :---- | :---- |
| `/spec:init` | 仕様書テンプレートを生成 | **定義**（仕様の明確化） |
| `/spec:review` | 仕様書の品質をチェック | **定義**（品質保証） |
| `/plan:make` | 仕様書に基づき実装計画を策定 | **計画**（手順の合意） |
| `/impl:run` | 計画に沿ってコードを実装 | **実装**（自律コーディング） |
| `/qa:full` | テスト設計・実行・結果整理を一括実行 | **検証**（品質保証） |
| `/git:commit` | 規約に沿ったコミットログを作成 | **完了**（履歴管理） |
| `/git:pr` | プルリクエストを作成 | **完了**（レビュー依頼） |
| `/gh:commit-push-pr` | コミット→プッシュ→PR作成を統合実行 | **完了**（統合ワークフロー） |

カスタムコマンドは `~/.claude/commands/` にMarkdownファイルとして配置することで、どのプロジェクトでも利用できます。

### **3-2. スキル（Skills）**

スキルは、特定のタスクに関するノウハウや手順をひとまとめにした「知識パック」です。

#### **Claude Code 公式機能**

Skills は Claude Code の公式機能で、以下の特徴があります。

- **自動適用:** Claudeがユーザーの依頼内容を分析し、関連するスキルを自動的に選択・適用
- **プログレッシブディスクロージャー:** 必要な情報のみを段階的に読み込み、コンテキストを効率的に使用
- **モジュール化:** 指示、スクリプト、リソースをフォルダ単位で管理

スキルは `.claude/skills/` または `~/.claude/skills/` ディレクトリに `SKILL.md` ファイルとして配置します。

#### **カスタムスキル（clauto-develop 提供）**

clauto-develop では、開発プロセスの品質を標準化するための9種類のカスタムスキルを提供しています。

| カテゴリ | スキル名 | 目的 |
| :---- | :---- | :---- |
| **仕様** | `spec-reviewer` | 仕様書のレビュー基準 |
| **設計** | `architecture-reviewer` | アーキテクチャレビュー |
| **実装** | `coding-standards` | コーディング規約の適用 |
| **テスト** | `test-author` | テスト作成パターン |
| **デバッグ** | `debug-triage` | デバッグ手法 |
| **レビュー** | `pr-reviewer` | PRレビュー基準 |
| **セキュリティ** | `security-baseline` | セキュリティチェック |
| **依存関係** | `dependency-change-reviewer` | 依存関係変更のリスク評価 |
| **リリース** | `release-notes-writer` | リリースノート作成 |

スキルは、ユーザーが明示的に指定しなくても、Claudeがタスク内容から判断して自動的に適用します。例えば、「このコードのセキュリティをチェックして」と依頼すると、`security-baseline` スキルが自動適用されます。

### **3-3. サブエージェント（Sub-agents）**

サブエージェントは、特定の役割を持つ専門家として振る舞うエージェントです。

#### **Claude Code 公式機能**

サブエージェントは Claude Code の Task ツールを通じて利用できる公式機能です。メインの会話とは独立したコンテキストで動作し、調査や分析などの複雑なタスクを自律的に実行します。

- **独立したコンテキスト:** メイン会話のコンテキストを消費せずに動作
- **専門的な役割:** 特定の視点や責任範囲を持って作業
- **成果物の引き継ぎ:** 調査結果や分析レポートをメイン会話に返却

#### **カスタムサブエージェント（clauto-develop 提供）**

clauto-develop では、スペック駆動開発の各フェーズに対応した10種類のカスタムサブエージェントを提供しています。

| エージェント | 役割グループ | 担当フェーズ |
| :---- | :---- | :---- |
| `req-analyzer` | Planner | 要求分析、要件定義 |
| `spec-planner` | Planner | 技術仕様書の作成 |
| `tech-leader` | Designer | 技術選定、アーキテクチャ設計 |
| `frontend-designer` | Designer | UI/UX設計、コンポーネント設計 |
| `backend-designer` | Designer | API設計、DB設計 |
| `code-builder` | Builder | コード実装、テスト作成 |
| `code-reviewer` | Reviewer | コードレビュー、品質チェック |
| `code-debugger` | Reviewer | バグ調査、修正 |
| `code-guide` | Guide | コードベースの案内、説明 |
| `general-purpose` | Guide | 汎用タスク対応 |

カスタムサブエージェントは `.claude/agents/` ディレクトリにMarkdownファイルとして配置します。

### **3-4. スキルとサブエージェントの併用**

スキルとサブエージェントは、それぞれ異なる目的で設計されており、併用することでより効果的な開発が可能になります。

| 観点 | スキル | サブエージェント |
| :---- | :---- | :---- |
| **起動方法** | 自動（Claude判断） | 自動/手動 |
| **コンテキスト** | メイン会話内 | 独立したコンテキスト |
| **用途** | 知識・ルールの適用 | 調査・分析タスク |

**併用例:**

```
[ユーザー] code-reviewer としてこのPRをレビューして

→ code-reviewer サブエージェントが起動
  → pr-reviewer スキルが自動適用（レビュー基準）
  → security-baseline スキルが自動適用（セキュリティ観点）
  → coding-standards スキルが自動適用（コーディング規約）
```

サブエージェントが「何をするか」を決め、スキルが「どのような基準で行うか」を提供するという関係になります。

## **4. 実践チュートリアル：新機能開発フロー**

clauto-develop のフレームワークでは、ECサイト構築を題材にしたチュートリアルを用意しています。

ここでは、おおまかな流れを説明します。

### **Step 0: 準備**

プロジェクトのルートに clauto-develop の設定ファイル（`.claude/` ディレクトリ等）が配置されていることを前提とします。

### **Step 1: 仕様の策定（/spec:init）**

まずはコードを書かず、仕様を固めます。

```
> /spec:init
> ユーザーがメールアドレスとパスワードでログインできる機能を実装したい。
> セキュリティ要件として、パスワードは8文字以上、ロックアウト機能も必要。
```

**Claudeの動作:**
- `spec-planner` サブエージェントが要求を分析
- `spec-reviewer` スキルの基準に従って仕様書を作成
- `docs/specs/login-feature.md` を生成（ユースケース、エラーハンドリング、DBスキーマ変更案を含む）

### **Step 2: 計画の立案（/plan:make）**

仕様書が承認されたら、実装計画を立てます。

```
> /plan:make docs/specs/login-feature.md を実装するための計画を立てて。
```

**Claudeの動作:**

Plan Mode でタスクリストを提示し、ユーザーの合意を求めます。

1. DBマイグレーション作成
2. APIエンドポイント実装
3. フロントエンド実装
4. テストコード作成

### **Step 3: 実装と検証（/impl:run & /qa:full）**

ここからはAIが自律的に動きます。Boris氏のベストプラクティスに従い、**テスト駆動**で進めます。

```
> /impl:run バックエンドのバリデーションロジックと、そのユニットテストを書いて。
```

実装が完了したら、検証コマンドを実行します。

```
> /qa:full
```

**Claudeの動作:**
- `code-builder` サブエージェントが実装を担当
- `coding-standards` スキルに従ってコードを生成
- 自動的にテストランナーを起動
- エラーが出れば、それを読み取って修正案を提示・適用（Verification Loop）

### **Step 4: レビューとコミット（/git:commit）**

全てのテストが通ったら、作業を保存します。

```
> /git:commit
```

**Claudeの動作:**
- 変更内容を解析し、規約に沿ったコミットメッセージを生成
- `code-reviewer` サブエージェントによるセルフレビューも可能

## **5. まとめと次のステップ**

clauto-develop は、Claude Code を単なる「賢いエディタ」から**「頼れる開発パートナー」**へと進化させます。

* **仕様ファースト:** AIの暴走を防ぎ、手戻りを最小化
* **ベストプラクティスの自動化:** Boris Cherny氏の知見を意識せずとも実践できる
* **拡張性:** 自社の開発ルールに合わせてカスタムコマンド・スキル・エージェントを追加可能

このフレームワーク導入により、エンジニアは「コードを書く」作業から解放され、「どのようなソフトウェアを作るべきか」という**本質的な設計と意思決定**に集中できるようになります。

まずはリポジトリをクローンし、テンプレートをコピーするところから始めてみましょう。

```bash
# リポジトリをクローン
git clone https://github.com/K-Suzumura/clauto-develop.git
cd clauto-develop

# カスタムコマンドをインストール
mkdir -p ~/.claude/commands
cp global-commands/*.md ~/.claude/commands/

# カスタムスキルをインストール
mkdir -p ~/.claude/skills
cp -r global-skills/* ~/.claude/skills/
```

詳細なセットアップ手順とECサイト構築チュートリアルは、リポジトリの `framework-docs/` ディレクトリを参照してください。
